<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dynamic Letter Generator</title>
    <!-- Quill CSS -->
    <link href="https://cdn.quilljs.com/1.3.6/quill.snow.css" rel="stylesheet">
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: #f4f7f9;
            color: #333;
            margin: 0;
            padding: 20px;
        }
        .app-container { max-width: 1100px; margin: 0 auto; background: #fff; padding: 20px; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.1); }
        nav { display: flex; flex-wrap: wrap; border-bottom: 2px solid #eee; padding-bottom: 10px; margin-bottom: 20px; }
        nav button { padding: 10px 20px; border: none; background: #007bff; color: white; cursor: pointer; border-radius: 5px; margin-right: 10px; margin-bottom: 5px; font-size: 16px; transition: background 0.3s; }
        nav button:hover { background: #0056b3; }
        .view { display: none; animation: fadeIn 0.5s; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        h1 { color: #007bff; border-bottom: 1px solid #ddd; padding-bottom: 10px; }
        h3 { margin-top: 20px; border-bottom: 1px solid #eee; padding-bottom: 5px;}
        hr { border: 0; border-top: 2px solid #eee; margin: 20px 0; }
        .controls { display: flex; gap: 20px; margin-bottom: 20px; }
        .control-group, .setting-group { flex: 1; margin-bottom: 20px; }
        label { display: block; margin-bottom: 8px; font-weight: bold; color: #555; }
        select, input[type="file"], input[type="text"], input[type="url"] { width: 100%; box-sizing: border-box; padding: 10px; border: 1px solid #ccc; border-radius: 4px; font-size: 14px; }
        #fileStatus, #fileName { margin-top: 10px; font-weight: bold; }
        button { padding: 10px 20px; border: none; background: #28a745; color: white; cursor: pointer; border-radius: 5px; font-size: 16px; transition: background 0.3s; }
        button:hover { background: #218838; }
        .delete-button { background-color: #dc3545; }
        .delete-button:hover { background-color: #c82333; }
        .letter-output { border: 1px solid #ddd; padding: 40px; min-height: 500px; background-color: #fff; border-radius: 4px; color: #000; }
        .editor-layout { display: flex; gap: 20px; }
        .placeholder-container { flex: 1; background-color: #f8f9fa; padding: 15px; border-radius: 5px; border: 1px solid #dee2e6; align-self: flex-start; }
        #placeholder-list { display: flex; flex-wrap: wrap; gap: 8px; }
        .placeholder-tag { background-color: #007bff; color: white; padding: 5px 10px; border-radius: 15px; font-size: 14px; cursor: pointer; user-select: none; transition: background-color 0.2s; }
        .placeholder-tag:hover { background-color: #0056b3; }
        .editor-container { flex: 3; }
        input#templateName { margin-bottom: 10px; }
        .editor-buttons, .data-buttons { margin-top: 10px; display: flex; flex-wrap: wrap; gap: 10px; }
        .editor-buttons button, .data-buttons button { margin-top: 0; }
        #migration-section { display: none; background-color: #fffbe6; border: 1px solid #ffe58f; padding: 15px; border-radius: 4px; }
        .generator-actions { display: flex; gap: 10px; }
        #saved-files-list ul { list-style-type: none; padding: 0; }
        #saved-files-list li { border: 1px solid #ddd; padding: 10px; margin-bottom: 10px; display: flex; justify-content: space-between; align-items: center; border-radius: 4px; }
    </style>
</head>
<body>
    <div class="app-container">
        <nav>
            <button onclick="showView('generatorView')">Letter Generator</button>
            <button onclick="showView('templateEditorView')">Template Editor</button>
            <button onclick="showView('savedFilesView')">Saved Letters</button>
            <button onclick="showView('settingsView')">Settings & Data</button>
        </nav>

        <div id="generatorView" class="view">
            <h1>Generate Letter</h1>
            <div class="controls">
                <div class="control-group">
                    <label for="templateSelector">Select Template:</label>
                    <select id="templateSelector" onchange="generateLetter()"></select>
                </div>
                <div class="control-group">
                    <label for="dataSelector">Select Data Row:</label>
                    <select id="dataSelector" onchange="generateLetter()"></select>
                </div>
            </div>
             <hr>
            <h3>Manual Placeholder Inputs</h3>
            <div id="manualInputs"></div>
            <button onclick="generateLetterManualFromPlaceholders()">Generate with Manual Inputs</button>
            <hr>
            <div class="generator-actions">
                <button onclick="printLetter()">Print Letter</button>
                <button onclick="generateAndSaveDocx()">Download & Save .docx</button>
            </div>
            <div id="letter-output" class="letter-output ql-editor">Select a template and data row.</div>
        </div>

        <div id="templateEditorView" class="view">
            <h1>Template Editor</h1>
            <div class="setting-group">
                <h3>Import from .docx</h3>
                <label for="docx-upload">Upload a .docx file to use as a template:</label>
                <input type="file" id="docx-upload" accept=".docx">
                <hr>
            </div>
            <div class="editor-layout">
                <div class="editor-container">
                    <label for="templateName">Template Name:</label>
                    <input type="text" id="templateName" placeholder="Enter a name for this template">
                    <div id="templateEditor"></div>
                    <div class="editor-buttons">
                        <button onclick="saveTemplate()">Save Template</button>
                        <button class="delete-button" onclick="deleteTemplate()">Delete Template</button>
                        <button onclick="loadTemplateForEditing()">Load Selected Template</button>
                        <button onclick="scanPlaceholdersFromTemplate()">Scan for Placeholders</button>
                    </div>
                </div>
                <div class="placeholder-container">
                    <h3>Available Placeholders</h3>
                    <div id="placeholder-list"></div>
                </div>
            </div>
        </div>
        
        <div id="savedFilesView" class="view">
            <h1>Saved .docx Letters</h1>
            <p>These are the .docx files you have generated and saved in your browser. Click to download again.</p>
            <div id="saved-files-list"></div>
        </div>

        <div id="settingsView" class="view">
            <h1>Settings & Data</h1>
            <div id="migration-section">
                <h3>Data Migration</h3>
                <p>Old data from a previous version was found. Click to migrate it to the new, more reliable database.</p>
                <button onclick="runMigration()">Migrate from Old Storage</button>
                <hr>
            </div>
            <div class="setting-group">
                <h3>Data Source</h3>
                <label for="fileInput">Upload Excel File (.xlsx, .xls, .csv):</label>
                <input type="file" id="fileInput" accept=".xlsx, .xls, .csv">
                <div id="fileName">No file selected</div>
                <div id="fileStatus">0 rows loaded.</div>
            </div>
            <hr>
            <div class="setting-group">
                <h3>Document Header</h3>
                <div id="headerEditor"></div>
                <button onclick="saveHeaderFooter()" style="margin-top: 10px;">Save Header & Footer</button>
            </div>
             <hr>
             <div class="setting-group">
                <h3>Document Footer</h3>
                <div id="footerEditor"></div>
            </div>
             <hr>
             <div class="setting-group">
                <h3>Print Font Settings</h3>
                <label for="fontSelector">Select a Font for Printing:</label>
                <select id="fontSelector">
                    <option value="Times New Roman">Times New Roman</option>
                    <option value="Arial">Arial</option>
                    <option value="Georgia">Georgia</option>
                    <option value="Courier New">Courier New</option>
                    <option value="Verdana">Verdana</option>
                </select>
                <label for="googleFontUrl" style="margin-top: 15px;">Or, use a Google Font (paste URL here):</label>
                <input type="url" id="googleFontUrl" placeholder="e.g., https://fonts.googleapis.com/css2?family=Roboto&display=swap">
                <button onclick="saveFontSettings()" style="margin-top: 10px;">Save Font Settings</button>
            </div>
             <hr>
             <div class="setting-group">
                <h3>Manage Data & Templates</h3>
                <div class="data-buttons">
                    <button onclick="exportTemplates()">Export All Templates (Backup)</button>
                    <button class="delete-button" onclick="clearExcelData()">Clear Saved Excel Data</button>
                    <button class="delete-button" onclick="resetApplication()">Reset Application</button>
                </div>
            </div>
        </div>

        <div id="templates" style="display: none;"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.17.5/xlsx.full.min.js"></script>
    <script src="https://cdn.quilljs.com/1.3.6/quill.js"></script>
    <script src="https://unpkg.com/html-docx-js/dist/html-docx.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.4.2/mammoth.browser.min.js"></script>

    <script>
        // --- GLOBAL VARIABLES ---
        let excelData = [], excelHeaders = [];
        let quill, headerEditor, footerEditor;
        const customPlaceholders = new Set();
        let db;

        // --- INDEXEDDB DATABASE HELPER ---
        const DB_NAME = 'LetterGenDB';
        const DB_VERSION = 2; 
        const STORES = {
            TEMPLATES: 'templates',
            DATA: 'data',
            SETTINGS: 'settings',
            GENERATED_FILES: 'generated_files'
        };

        function openDB() {
            return new Promise((resolve, reject) => {
                if (db) return resolve(db);
                const request = indexedDB.open(DB_NAME, DB_VERSION);
                request.onerror = (event) => reject('IndexedDB error: ' + event.target.errorCode);
                request.onsuccess = (event) => { db = event.target.result; resolve(db); };
                request.onupgradeneeded = (event) => {
                    const dbInstance = event.target.result;
                    Object.values(STORES).forEach(storeName => {
                        if (!dbInstance.objectStoreNames.contains(storeName)) {
                            dbInstance.createObjectStore(storeName);
                        }
                    });
                };
            });
        }

        async function dbGet(storeName, key) {
            const db = await openDB();
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(storeName, 'readonly');
                const store = transaction.objectStore(storeName);
                const request = store.get(key);
                request.onsuccess = () => resolve(request.result);
                request.onerror = (event) => reject('Get error: ' + event.target.errorCode);
            });
        }

        async function dbSet(storeName, key, value) {
            const db = await openDB();
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(storeName, 'readwrite');
                const store = transaction.objectStore(storeName);
                const request = store.put(value, key);
                request.onsuccess = () => resolve(true);
                request.onerror = (event) => reject('Set error: ' + event.target.errorCode);
            });
        }
        
        async function dbDelete(storeName, key) {
             const db = await openDB();
             return new Promise((resolve, reject) => {
                const transaction = db.transaction(storeName, 'readwrite');
                const store = transaction.objectStore(storeName);
                const request = store.delete(key);
                request.onsuccess = () => resolve(true);
                request.onerror = (event) => reject('Delete error: ' + event.target.errorCode);
            });
        }

        async function dbGetAll(storeName) {
            const db = await openDB();
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(storeName, 'readonly');
                const store = transaction.objectStore(storeName);
                const items = {};
                const cursorRequest = store.openCursor();
                cursorRequest.onsuccess = event => {
                    const cursor = event.target.result;
                    if (cursor) {
                        items[cursor.key] = cursor.value;
                        cursor.continue();
                    } else {
                        resolve(items);
                    }
                };
                cursorRequest.onerror = event => reject('Failed to retrieve data: ' + event.target.errorCode);
            });
        }
        
        // --- UTILITY & CORE LOGIC ---
        function formatDate(dateString) {
            if (!dateString) return '';
            const date = new Date(dateString.replace(/-/g, '/'));
            if (isNaN(date.getTime())) return dateString;
            return `${String(date.getDate()).padStart(2, '0')}/${String(date.getMonth() + 1).padStart(2, '0')}/${date.getFullYear()}`;
        }

        function showView(viewId) {
            document.querySelectorAll('.view').forEach(v => v.style.display = 'none');
            document.getElementById(viewId).style.display = 'block';
            if (viewId === 'templateEditorView' && !quill) quill = createQuillEditor('templateEditor');
            if (viewId === 'settingsView') {
                if (!headerEditor) headerEditor = createQuillEditor('headerEditor');
                if (!footerEditor) footerEditor = createQuillEditor('footerEditor');
                loadHeaderFooter();
            }
            if (viewId === 'savedFilesView') {
                loadSavedFiles();
            }
        }
        
        // --- INITIALIZATION ---
        function createQuillEditor(elementId) {
            const toolbarOptions = [
                [{ 'header': [1, 2, 3, 4, 5, 6, false] }],
                ['bold', 'italic', 'underline'],
                [{ 'align': [] }],
                ['link', 'image'],
                ['clean']
            ];
            return new Quill(`#${elementId}`, {
                theme: 'snow',
                modules: { toolbar: toolbarOptions }
            });
        }

        // --- DATA & SETTINGS HANDLING ---
        async function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) { document.getElementById('fileName').textContent = "No file selected"; return; }
            document.getElementById('fileName').textContent = `File: ${file.name}`;
            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, { type: 'array' });
                    const ws = workbook.Sheets[workbook.SheetNames[0]];
                    excelHeaders = XLSX.utils.sheet_to_json(ws, { header: 1, raw: false, defval: '' })[0] || [];
                    excelData = XLSX.utils.sheet_to_json(ws, { header: excelHeaders, raw: false, defval: '', range: 1 });
                    
                    const dataToSave = { headers: excelHeaders, data: excelData, fileName: file.name };
                    await dbSet(STORES.DATA, 'excelDataSource', dataToSave);
                    alert('Excel data has been saved.');
                    updateUIAfterDataLoad(file.name);
                } catch (err) {
                    console.error("Error reading or saving Excel file:", err);
                    alert("An error occurred. Please check the file format.");
                }
            };
            reader.readAsArrayBuffer(file);
        }

        async function handleDocxUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                mammoth.convertToHtml({ arrayBuffer: e.target.result })
                    .then(function(result) {
                        if (quill) {
                            quill.root.innerHTML = result.value;
                        }
                        document.getElementById('templateName').value = file.name.replace(/\.docx$/, '');
                        alert('DOCX content loaded into the editor.');
                    })
                    .catch(function(err) {
                        console.log(err);
                        alert('Error converting .docx file. See console for details.');
                    });
            };
            reader.readAsArrayBuffer(file);
        }

        async function loadSavedData() {
            const savedData = await dbGet(STORES.DATA, 'excelDataSource');
            if (savedData) {
                excelData = savedData.data || [];
                excelHeaders = savedData.headers || [];
                updateUIAfterDataLoad(savedData.fileName || 'Loaded from database');
            }
        }
        
        function updateUIAfterDataLoad(fileName) {
            document.getElementById('fileName').textContent = `File: ${fileName}`;
            document.getElementById('fileStatus').textContent = `${excelData.length} rows loaded.`;
            populateDataSelector();
            displayPlaceholders();
            generateLetter();
        }

        async function clearExcelData() {
            if (confirm('Are you sure you want to clear the saved Excel data?')) {
                await dbDelete(STORES.DATA, 'excelDataSource');
                excelData = [];
                excelHeaders = [];
                updateUIAfterDataLoad('No file selected');
                document.getElementById('fileStatus').textContent = '0 rows loaded.';
                alert('Saved Excel data has been cleared.');
            }
        }

        async function saveFontSettings() {
            const selectedFont = document.getElementById('fontSelector').value;
            const googleFontUrl = document.getElementById('googleFontUrl').value.trim();
            const fontSettings = { font: selectedFont, url: googleFontUrl };
            await dbSet(STORES.SETTINGS, 'printFontSettings', fontSettings);
            alert('Font settings saved!');
        }
        
        async function saveHeaderFooter() {
            if (!headerEditor || !footerEditor) {
                alert('Error: The header/footer editors are not initialized. Please ensure you are on the Settings tab.');
                return;
            }
            const headerContent = headerEditor.root.innerHTML;
            const footerContent = footerEditor.root.innerHTML;
            await dbSet(STORES.SETTINGS, 'printHeader', headerContent);
            await dbSet(STORES.SETTINGS, 'printFooter', footerContent);
            alert('Header and Footer saved!');
        }

        async function loadFontSettings() {
            const settings = await dbGet(STORES.SETTINGS, 'printFontSettings');
            if (settings) {
                document.getElementById('fontSelector').value = settings.font || 'Times New Roman';
                document.getElementById('googleFontUrl').value = settings.url || '';
            }
        }
        
        async function loadHeaderFooter() {
            const headerContent = await dbGet(STORES.SETTINGS, 'printHeader');
            if (headerEditor && headerContent) headerEditor.root.innerHTML = headerContent;
            
            const footerContent = await dbGet(STORES.SETTINGS, 'printFooter');
            if (footerEditor && footerContent) footerEditor.root.innerHTML = footerContent;
        }

        // --- UI & LETTER GENERATION ---
        function displayPlaceholders() {
            const list = document.getElementById('placeholder-list');
            list.innerHTML = '';
            excelHeaders.forEach(h => {
                if (!h) return;
                const tag = document.createElement('span');
                tag.className = 'placeholder-tag';
                tag.textContent = `{{${h}}}`;
                tag.onclick = () => quill ? quill.insertText(quill.getSelection(true).index, tag.textContent) : alert("Activate the editor first.");
                list.appendChild(tag);
            });
        }

        function populateDataSelector() {
            const selector = document.getElementById('dataSelector');
            selector.innerHTML = '';
            excelData.forEach((row, index) => selector.add(new Option(row[excelHeaders[0]] || `Row ${index + 1}`, index)));
            selector.value = "";
        }

        function generateLetter() {
            const outputDiv = document.getElementById('letter-output');
            const dataIndex = document.getElementById('dataSelector').value;
            const templateId = document.getElementById('templateSelector').value;
            const templateDiv = document.getElementById(templateId);

            if (!templateDiv) { outputDiv.innerHTML = 'Select a template.'; return; }
            if (dataIndex === "" && excelData.length > 0) { outputDiv.innerHTML = 'Select a data row.'; return; }
            if (excelData.length === 0) { outputDiv.innerHTML = 'Upload an Excel file in Settings.'; return; }
            
            let content = templateDiv.innerHTML;
            const row = excelData[dataIndex];
            excelHeaders.forEach(header => {
                if (header && row.hasOwnProperty(header)) {
                    const placeholder = new RegExp(`{{${header}}}`, 'g');
                    let value = row[header] || '';
                    if (header.toLowerCase() === 'dated') value = formatDate(value);
                    content = content.replace(placeholder, value);
                }
            });
            outputDiv.innerHTML = content;
        }
        
        function scanPlaceholdersFromTemplate() {
            if (!quill) { alert('Please open Template Editor to scan placeholders.'); return; }
            const text = quill.getText();
            const regex = /{{(.*?)}}/g;
            customPlaceholders.clear();
            let match;
            while ((match = regex.exec(text)) !== null) {
                if (match[1]) customPlaceholders.add(match[1].trim());
            }
            alert(`Found placeholders: ${Array.from(customPlaceholders).join(', ')}`);
            createManualInputsFromPlaceholders();
        }

        function createManualInputsFromPlaceholders() {
            const manualInputsContainer = document.getElementById('manualInputs');
            manualInputsContainer.innerHTML = '';
            customPlaceholders.forEach(ph => {
                const label = document.createElement('label');
                label.textContent = ph + ':';
                const input = document.createElement('input');
                input.type = 'text';
                input.id = `manual_${ph}`;
                input.placeholder = `Enter value for {{${ph}}}`;
                manualInputsContainer.appendChild(label);
                manualInputsContainer.appendChild(input);
            });
        }

        function generateLetterManualFromPlaceholders() {
            const outputDiv = document.getElementById('letter-output');
            const templateId = document.getElementById('templateSelector').value;
            const templateDiv = document.getElementById(templateId);
            if (!templateDiv) { outputDiv.innerHTML = 'Select a template.'; return; }
            let content = templateDiv.innerHTML;
            customPlaceholders.forEach(ph => {
                const inputElement = document.getElementById(`manual_${ph}`);
                const manualInputValue = inputElement ? inputElement.value : '';
                content = content.replace(new RegExp(`{{${ph}}}`, 'g'), manualInputValue);
            });
            outputDiv.innerHTML = content;
        }

        // --- TEMPLATE MANAGEMENT ---
        async function saveTemplate() {
            if (!quill) quill = createQuillEditor('templateEditor');
            const name = document.getElementById('templateName').value.trim();
            const htmlContent = quill.root.innerHTML;
            if (!name || (quill.getLength() <= 1)) { alert('Please provide a template name and content.'); return; }
            
            const templateData = { html: htmlContent, placeholders: Array.from(customPlaceholders) };
            try {
                await dbSet(STORES.TEMPLATES, name, templateData);
                alert(`Template "${name}" saved!`);
                await loadAllTemplates();
            } catch(e) {
                console.error("Failed to save template:", e);
                alert("An error occurred while saving the template to the database.");
            }
        }

        async function deleteTemplate() {
            const name = document.getElementById('templateName').value.trim();
            if (!name) { alert('Load a template to delete it.'); return; }
            if (confirm(`Are you sure you want to delete "${name}"?`)) {
                await dbDelete(STORES.TEMPLATES, name);
                alert(`Template "${name}" deleted.`);
                document.getElementById('templateName').value = '';
                if (quill) quill.root.innerHTML = '';
                await loadAllTemplates();
            }
        }
        
        async function loadAllTemplates() {
            const selector = document.getElementById('templateSelector');
            selector.innerHTML = '';
            const container = document.getElementById('templates');
            container.innerHTML = '';
            
            try {
                const templates = await dbGetAll(STORES.TEMPLATES);
                const templateNames = Object.keys(templates);
                if (templateNames.length === 0) {
                    selector.add(new Option("-- No Templates --", ""));
                } else {
                    templateNames.forEach(name => {
                        selector.add(new Option(name, `custom-${name}`));
                        const div = document.createElement('div');
                        div.id = `custom-${name}`;
                        div.innerHTML = templates[name].html;
                        container.appendChild(div);
                    });
                }
                customPlaceholders.clear();
                createManualInputsFromPlaceholders();
                generateLetter();
            } catch (err) {
                console.error("Failed to load templates:", err);
                selector.innerHTML = '<option>Error loading templates</option>';
            }
        }

        async function loadTemplateForEditing() {
            if (!quill) quill = createQuillEditor('templateEditor');
            const selectedId = document.getElementById('templateSelector').value;
            if (!selectedId.startsWith('custom-')) {
                document.getElementById('templateName').value = '';
                if (quill) quill.root.innerHTML = '';
                customPlaceholders.clear();
                createManualInputsFromPlaceholders();
                return;
            }
            const name = selectedId.replace('custom-', '');
            const templateData = await dbGet(STORES.TEMPLATES, name);
            if (templateData) {
                document.getElementById('templateName').value = name;
                if (quill) quill.root.innerHTML = templateData.html || '';
                customPlaceholders.clear();
                if (templateData.placeholders) templateData.placeholders.forEach(ph => customPlaceholders.add(ph));
                createManualInputsFromPlaceholders();
            }
        }
        
        async function exportTemplates() {
            const templates = await dbGetAll(STORES.TEMPLATES);
            if (Object.keys(templates).length === 0) { alert("No templates to export."); return; }
            const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(templates, null, 2));
            const a = document.createElement('a');
            a.href = dataStr;
            a.download = `templates_backup_${new Date().toISOString().replace(/:/g, '-')}.json`;
            a.click();
        }
        
        async function resetApplication() {
            if (confirm("This will clear ALL saved data. Are you sure? A backup of your templates will be downloaded first.")) {
                await exportTemplates();
                await new Promise((resolve, reject) => {
                    const deleteRequest = indexedDB.deleteDatabase(DB_NAME);
                    deleteRequest.onsuccess = () => resolve();
                    deleteRequest.onerror = () => reject('Could not delete database.');
                    deleteRequest.onblocked = () => alert('Database is blocked. Please close other tabs with this app open and try again.');
                });
                window.location.reload();
            }
        }

        // --- PRINT & DOWNLOAD FUNCTIONS ---

        async function printLetter() {
            const contentToPrint = document.getElementById('letter-output').innerHTML;
            const headerContent = await dbGet(STORES.SETTINGS, 'printHeader') || '';
            const footerContent = await dbGet(STORES.SETTINGS, 'printFooter') || '';
            const fontSettings = await dbGet(STORES.SETTINGS, 'printFontSettings') || { font: 'Times New Roman', url: '' };
            
            const printWindow = window.open('', '_blank');
            printWindow.document.write('<html><head><title>Print Letter</title>');
            printWindow.document.write('<link href="https://cdn.quilljs.com/1.3.6/quill.snow.css" rel="stylesheet">');
            if(fontSettings.url) printWindow.document.write(`<link href="${fontSettings.url}" rel="stylesheet">`);
            printWindow.document.write(`<style> body { font-family: '${fontSettings.font}', serif; margin: 40px; } @media print { html, body, .ql-editor { height: auto !important; overflow: visible !important; } } .print-header { margin-bottom: 20px; border-bottom: 1px solid #ccc; padding-bottom: 10px; } .print-footer { margin-top: 20px; border-top: 1px solid #ccc; padding-top: 10px; font-size: 0.8em; color: #666; } </style>`);
            printWindow.document.write('</head><body>');
            printWindow.document.write(`<div class="print-header ql-editor">${headerContent}</div>`);
            printWindow.document.write(`<div class="main-content ql-editor">${contentToPrint}</div>`);
            printWindow.document.write(`<div class="print-footer ql-editor">${footerContent}</div>`);
            printWindow.document.write('</body></html>');
            printWindow.document.close();
            printWindow.onload = () => { printWindow.focus(); printWindow.print(); printWindow.close(); };
        }

        async function generateAndSaveDocx() {
            const content = document.getElementById('letter-output').innerHTML;
            const header = await dbGet(STORES.SETTINGS, 'printHeader') || '';
            const footer = await dbGet(STORES.SETTINGS, 'printFooter') || '';
            const fullHtml = `<!DOCTYPE html><html><head><meta charset="UTF-8"></head><body><header>${header}</header><main>${content}</main><footer>${footer}</footer></body></html>`;
            
            const blob = htmlDocx.asBlob(fullHtml);
            const filename = `letter_${new Date().toISOString().replace(/[:.]/g, '-')}.docx`;

            const fileData = { name: filename, blob: blob, date: new Date().toLocaleString() };
            await dbSet(STORES.GENERATED_FILES, filename, fileData);

            saveAs(blob, filename);
            alert(`'${filename}' has been downloaded and saved to the "Saved Letters" tab.`);
        }

        async function loadSavedFiles() {
            const listContainer = document.getElementById('saved-files-list');
            listContainer.innerHTML = 'Loading...';
            try {
                const savedFiles = await dbGetAll(STORES.GENERATED_FILES);
                const fileNames = Object.keys(savedFiles);

                if (fileNames.length === 0) {
                    listContainer.innerHTML = '<p>No saved files yet.</p>';
                    return;
                }

                listContainer.innerHTML = ''; 
                const ul = document.createElement('ul');
                fileNames.reverse().forEach(name => {
                    const file = savedFiles[name];
                    const li = document.createElement('li');
                    const infoDiv = document.createElement('div');
                    infoDiv.innerHTML = `<strong>${file.name}</strong><br><small>Saved on: ${file.date}</small>`;
                    const downloadButton = document.createElement('button');
                    downloadButton.textContent = 'Download';
                    downloadButton.onclick = () => downloadSavedFile(file.name);
                    li.appendChild(infoDiv);
                    li.appendChild(downloadButton);
                    ul.appendChild(li);
                });
                listContainer.appendChild(ul);
            } catch (err) {
                listContainer.innerHTML = '<p>Error loading saved files. The database might be upgrading.</p>';
                console.error('Error loading saved files:', err);
            }
        }

        async function downloadSavedFile(filename) {
            try {
                const fileData = await dbGet(STORES.GENERATED_FILES, filename);
                if (fileData && fileData.blob) {
                    saveAs(fileData.blob, fileData.name);
                } else {
                    alert('File not found in the database.');
                }
            } catch (err) {
                alert('Error downloading file.');
                console.error('Error downloading saved file:', err);
            }
        }
        
        // --- DATA MIGRATION ---

        async function handleMigrationLogic() {
            const oldTemplatesRaw = localStorage.getItem('customTemplates');
            try {
                const oldTemplates = JSON.parse(oldTemplatesRaw);
                const migrationPromises = Object.keys(oldTemplates).map(templateName => dbSet(STORES.TEMPLATES, templateName, oldTemplates[templateName]));
                await Promise.all(migrationPromises);
                localStorage.removeItem('customTemplates');
                alert("Data migration successful! The page will now reload.");
                window.location.reload();
            } catch (e) {
                alert("Data migration failed. See console for details.");
                console.error("Migration Error:", e);
            }
        }

        function checkForMigration() {
            if (localStorage.getItem('customTemplates')) {
                document.getElementById('migration-section').style.display = 'block';
            }
        }

        async function runMigration() {
            if (confirm("Are you sure you want to migrate data from the old storage system? This is a one-time process.")) {
                await handleMigrationLogic();
            }
        }

        // --- DOCUMENT READY ---
        document.addEventListener('DOMContentLoaded', async () => {
            await openDB(); 
            checkForMigration(); 
            document.getElementById('fileInput').addEventListener('change', handleFileUpload);
            document.getElementById('docx-upload').addEventListener('change', handleDocxUpload);
            showView('generatorView');
            await loadSavedData();
            await loadAllTemplates();
            await loadFontSettings();
        });
    </script>
</body>
</html>
